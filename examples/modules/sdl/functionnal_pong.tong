// Functional-style Pong using pattern matching & immutable state transitions
// NOTE: This is an experimental functional re-imagining of pong.tong leveraging
// data declarations, pattern clause functions, guards, and pure update pipelines.
// SDL rendering is still effectful; we isolate side-effects at the edge (main loop).

// ---------- Data Models ----------

data Direction = Up | Down | None

data Side = Left | Right

// Outcome removed for simplicity; simulation returns updated Game directly

// Immutable game state record encoded as a constructor
// We emulate a record via positional constructor; commentary indicates fields:
// Game(ball_x, ball_y, vx, vy, p1y, p2y, score1, score2, running)
data Game = Game ball_x ball_y vx vy p1y p2y s1 s2 running

// ---------- Constants ----------

def width() { 800 }

def height() { 600 }

def paddle_w() { 15 }

def paddle_h() { 80 }

def ball_size() { 12 }

def paddle_speed() { 8 }

def init_ball_vx() { 5 }

def init_ball_vy() { 4 }

// ---------- Pure Helpers ----------

// Clamp a value
fn clamp(v, lo, hi) { if v < lo { lo } else { if v > hi { hi } else { v } } }

// Reset ball centered with specified vx sign (+/-)
fn reset_ball(state, vx_sign) {
  let vx = init_ball_vx() * vx_sign
  let vy = init_ball_vy()
  Game(width()/2, height()/2, vx, vy, p1y(state), p2y(state), s1(state), s2(state), is_running(state))
}

// Pattern clause accessors for readability (since we used positional constructor)
// We rely on destructuring via pattern matching sugar.

def ball_x(Game(x,_,_,_,_,_,_,_,_)) { x }

def ball_y(Game(_,y,_,_,_,_,_,_,_)) { y }

def vx(Game(_,_,vx,_,_,_,_,_,_)) { vx }

def vy(Game(_,_,_,vy,_,_,_,_,_)) { vy }

def p1y(Game(_,_,_,_,p1,_,_,_,_)) { p1 }

def p2y(Game(_,_,_,_,_,p2,_,_,_)) { p2 }

def s1(Game(_,_,_,_,_,_,s1,_,_)) { s1 }

def s2(Game(_,_,_,_,_,_,_,s2,_)) { s2 }

def is_running(Game(_,_,_,_,_,_,_,_,r)) { r }

// Replace fields (persistent style). We rebuild a new Game each time.
fn with_ball(state, nx, ny, nvx, nvy) {
  Game(nx, ny, nvx, nvy, p1y(state), p2y(state), s1(state), s2(state), is_running(state))
}
fn with_p1y(state, ny) { Game(ball_x(state), ball_y(state), vx(state), vy(state), ny, p2y(state), s1(state), s2(state), is_running(state)) }
fn with_p2y(state, ny) { Game(ball_x(state), ball_y(state), vx(state), vy(state), p1y(state), ny, s1(state), s2(state), is_running(state)) }
fn with_scores(state, ns1, ns2) { Game(ball_x(state), ball_y(state), vx(state), vy(state), p1y(state), p2y(state), ns1, ns2, is_running(state)) }
fn with_running(state, r) { Game(ball_x(state), ball_y(state), vx(state), vy(state), p1y(state), p2y(state), s1(state), s2(state), r) }

// ---------- Input Mapping (pure) ----------
// Translate raw key state into paddle movement directions.
fn dir_from_keys(sdl, up_key, down_key) {
  if sdl.key_down(up_key) { Up } else { if sdl.key_down(down_key) { Down } else { None } }
}

fn apply_dir(y, dir) {
  match dir {
    Up -> clamp(y - paddle_speed(), 0, height() - paddle_h())
    Down -> clamp(y + paddle_speed(), 0, height() - paddle_h())
    None -> y
  }
}

// ---------- Physics & Collision (pure) ----------
fn step_ball(state) {
  let nx = ball_x(state) + vx(state)
  let ny = ball_y(state) + vy(state)
  with_ball(state, nx, ny, vx(state), vy(state))
}

fn wall_bounce(state) {
  let y = ball_y(state)
  if y <= 0 {
    with_ball(state, ball_x(state), 0, vx(state), -vy(state))
  } else {
    let bottom = height() - ball_size()
    if y >= bottom {
      with_ball(state, ball_x(state), bottom, vx(state), -vy(state))
    } else { state }
  }
}

fn paddle_collision_left(state) {
  if vx(state) >= 0 {
    state
  } else {
    let bx = ball_x(state)
    let by = ball_y(state)
    let p1x = 20
    let overlap_x = bx <= p1x + paddle_w()
    let overlap_y_part1 = by + ball_size() >= p1y(state)
    let overlap_y_part2 = by <= p1y(state) + paddle_h()
    let overlap_y_flag = 0
    if overlap_y_part1 { if overlap_y_part2 { overlap_y_flag = 1 } }
    if overlap_x {
      if overlap_y_flag == 1 {
        with_ball(state, p1x + paddle_w(), by, -vx(state), vy(state))
      } else { state }
    } else { state }
  }
}

fn paddle_collision_right(state) {
  if vx(state) <= 0 {
    state
  } else {
    let bx = ball_x(state)
    let by = ball_y(state)
    let p2x = width() - 20 - paddle_w()
    let overlap_x = bx + ball_size() >= p2x
    let overlap_y_part1 = by + ball_size() >= p2y(state)
    let overlap_y_part2 = by <= p2y(state) + paddle_h()
    let overlap_y_flag = 0
    if overlap_y_part1 { if overlap_y_part2 { overlap_y_flag = 1 } }
    if overlap_x {
      if overlap_y_flag == 1 {
        with_ball(state, p2x - ball_size(), by, -vx(state), vy(state))
      } else { state }
    } else { state }
  }
}

fn scoring(state) {
  let bx = ball_x(state)
  if bx < 0 {
    let ns = with_scores(state, s1(state), s2(state)+1)
    let rb = reset_ball(ns, 1)
    print("Score:", s1(rb), "-", s2(rb))
    rb
  } else {
    if bx > width() {
      let ns = with_scores(state, s1(state)+1, s2(state))
      let rb = reset_ball(ns, -1)
      print("Score:", s1(rb), "-", s2(rb))
      rb
    } else { state }
  }
}

// Compose a single simulation tick (without input)
fn simulate(state) {
  let moved = step_ball(state)
  let wb = wall_bounce(moved)
  let pl = paddle_collision_left(wb)
  let pr = paddle_collision_right(pl)
  scoring(pr)
}

// Apply paddle inputs
fn apply_inputs(state, p1dir, p2dir) {
  let np1 = apply_dir(p1y(state), p1dir)
  let np2 = apply_dir(p2y(state), p2dir)
  with_p2y(with_p1y(state, np1), np2)
}

// ---------- Rendering (side-effect) ----------
fn draw_state(sdl, ren, state) {
  // background
  sdl.set_draw_color(ren, 30, 30, 50, 255)
  sdl.clear(ren)
  // center line
  sdl.fill_rect(ren, (width()/2)-2, 0, 4, height(), 255, 255, 255, 255)
  // paddles
  sdl.fill_rect(ren, 20, p1y(state), paddle_w(), paddle_h(), 0, 255, 255, 255)
  let p2x = width() - 20 - paddle_w()
  sdl.fill_rect(ren, p2x, p2y(state), paddle_w(), paddle_h(), 255, 0, 255, 255)
  // ball
  sdl.fill_rect(ren, ball_x(state), ball_y(state), ball_size(), ball_size(), 255, 255, 0, 255)
  // scores (reuse simple print rectangles as digits placeholder)
  // Minimalistic: just draw small blocks per point (<= 10) for demonstration
  let i = 0
  while i < s1(state) {
    sdl.fill_rect(ren, 360 - i*8, 10, 6, 12, 200,200,200,255)
    i = i + 1
  }
  let j = 0
  while j < s2(state) {
    sdl.fill_rect(ren, 440 + j*8, 10, 6, 12, 200,200,200,255)
    j = j + 1
  }
  sdl.present(ren)
}

// ---------- Main Loop (effect orchestration) ----------
// Outcome handling removed; scoring prints inline.

fn main() {
  let sdl = import("sdl")
  sdl.init()
  let win = sdl.create_window("Functional Pong (ESC/Q to quit)", width(), height())
  let ren = sdl.create_renderer(win)
  print("Functional Pong controls: W/S vs Up/Down, ESC or Q to quit")

  // Initial state
  let state = Game(width()/2, height()/2, init_ball_vx(), init_ball_vy(), (height()-paddle_h())/2, (height()-paddle_h())/2, 0, 0, true)

  let running = true
  while running {
    if sdl.poll_quit() { running = false }
    if sdl.key_down(sdl.K_ESCAPE) { running = false }
    if sdl.key_down(sdl.K_Q) { running = false }

    // Derive paddle intents
    let p1dir = dir_from_keys(sdl, sdl.K_W, sdl.K_S)
    let p2dir = dir_from_keys(sdl, sdl.K_UP, sdl.K_DOWN)

    // Advance one frame purely
    let moved_state = apply_inputs(state, p1dir, p2dir)
  state = simulate(moved_state)

    draw_state(sdl, ren, state)
    sdl.delay(16)
  }

  print("Game over. Final:", s1(state), "-", s2(state))
  sdl.destroy_renderer(ren)
  sdl.destroy_window(win)
  sdl.quit()
}

main()
