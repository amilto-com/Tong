// SDL Pong example using TONG's module system

// =============================
// New scoreboard implementation (array/index-free)
// =============================
// Simple 3x5 block font using explicit cell draw calls (no arrays, no indexing) to stay within
// the most basic supported language features.

fn digit_width(cell) { 3*cell + 2 } // 3 columns with a 1px gap between => 2 extra pixels

fn draw_cell(sdl, ren, x, y, cell, col, row, r,g,b,a) {
  let px = x + col * (cell + 1)
  let py = y + row * (cell + 1)
  sdl.fill_rect(ren, px, py, cell, cell, r,g,b,a)
}

// Draw digit d at (x,y)
fn draw_block_digit(sdl, ren, x, y, d, cell, r,g,b,a) {
  // Patterns defined as explicit (col,row) sets
  if d == 0 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 1 {
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 2 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 3 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 4 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 5 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 6 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 7 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
  }
  if d == 8 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
  if d == 9 {
    draw_cell(sdl,ren,x,y,cell,0,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,0,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,1,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,2,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,3,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,0,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,1,4,r,g,b,a)
    draw_cell(sdl,ren,x,y,cell,2,4,r,g,b,a)
  }
}

fn draw_number_left(sdl, ren, x, y, n, cell, r,g,b,a) {
  var tens = 0
  var temp = n
  while temp >= 10 {
    tens = tens + 1
    temp = temp - 10
  }
  let ones = n % 10
  if n >= 10 {
    draw_block_digit(sdl, ren, x, y, tens, cell, r,g,b,a)
    let adv = digit_width(cell) + cell
    draw_block_digit(sdl, ren, x + adv, y, ones, cell, r,g,b,a)
  } else {
    draw_block_digit(sdl, ren, x, y, ones, cell, r,g,b,a)
  }
}

fn draw_number_right_justified(sdl, ren, right_x, y, n, cell, r,g,b,a) {
  let single = digit_width(cell)
  let width = single
  if n >= 10 { width = single + cell + single }
  let start_x = right_x - width
  draw_number_left(sdl, ren, start_x, y, n, cell, r,g,b,a)
}

fn main() {
  let sdl = import("sdl")
  sdl.init()
  let win = sdl.create_window("TONG Pong - Press ESC or Q to quit", 800, 600)
  let ren = sdl.create_renderer(win)

  print("Controls: W/S (left paddle), UP/DOWN (right paddle), ESC/Q (quit)")
  print("Close window button should also work")

  // Debug toggle (set to true to trace)
  let debug = false
  var frame = 0

  // Game state
  var ball_x = 400
  var ball_y = 300
  var prev_x = ball_x
  var prev_y = ball_y
  var ball_vx = 5
  var ball_vy = 4
  let ball_size = 12
  let pw = 15
  let ph = 80
  let p1_x = 20
  let p2_x = 800 - 20 - pw
  var p1_y = 260
  var p2_y = 260
  var score1 = 0
  var score2 = 0

  // (Per-frame scoreboard constants were originally inside the loop; restoring original naming & placement)
  // We intentionally keep them simple (t,w,h,gap,top_y) for clarity and to match pre-branch behavior.

  var running = true
  while running {
    if debug { print("frame", frame, "pre loop running", running) }
    // Handle quit events - check window close button first
    let quit_evt = sdl.poll_quit()
    if debug { print("frame", frame, "poll_quit()", quit_evt) }
    if quit_evt {
      running = false
    }
    
    // Also allow ESC or Q to quit
    if sdl.key_down(sdl.K_ESCAPE) { 
      running = false 
    }
    if sdl.key_down(sdl.K_Q) { 
      running = false 
    }

    // Paddle controls
    if sdl.key_down(sdl.K_W) {
      p1_y = p1_y - 8
    }
    if sdl.key_down(sdl.K_S) {
      p1_y = p1_y + 8
    }
    if sdl.key_down(sdl.K_UP) {
      p2_y = p2_y - 8
    }
    if sdl.key_down(sdl.K_DOWN) {
      p2_y = p2_y + 8
    }

    // Clamp paddles to screen
    if p1_y < 0 { p1_y = 0 }
    if p1_y + ph > 600 { p1_y = 600 - ph }
    if p2_y < 0 { p2_y = 0 }
    if p2_y + ph > 600 { p2_y = 600 - ph }

  // Store previous position then move ball
  prev_x = ball_x
  prev_y = ball_y
    ball_x = ball_x + ball_vx
    ball_y = ball_y + ball_vy

    // Ball bounces off top/bottom walls
    if ball_y <= 0 { 
      ball_y = 0
      ball_vy = -ball_vy 
    }
    if ball_y >= 600 - ball_size { 
      ball_y = 600 - ball_size
      ball_vy = -ball_vy 
    }

  // Ball hits left paddle (swept AABB + direction check)
    if ball_vx < 0 {
      // Check if we've crossed the right edge of the left paddle
      if prev_x >= p1_x + pw {
        if ball_x <= p1_x + pw {
          // y overlap in either previous or current position
          if ball_y + ball_size >= p1_y { if ball_y <= p1_y + ph {
            // bounce
            ball_x = p1_x + pw
            ball_vx = -ball_vx
          } } else {
            if prev_y + ball_size >= p1_y { if prev_y <= p1_y + ph {
              // bounce (swept)
              ball_x = p1_x + pw
              ball_vx = -ball_vx
            } }
          }
        }
      } else {
        // Fallback to current AABB overlap
        if ball_x <= p1_x + pw { if ball_x + ball_size >= p1_x { if ball_y + ball_size >= p1_y { if ball_y <= p1_y + ph {
          // bounce (AABB)
          ball_x = p1_x + pw
          ball_vx = -ball_vx
        }}}}
      }
    }

  // Ball hits right paddle (swept AABB + direction check)
    if ball_vx > 0 {
      // Check if we've crossed the left edge of the right paddle
      if prev_x + ball_size <= p2_x {
        if ball_x + ball_size >= p2_x {
          // y overlap in either previous or current position
          if ball_y + ball_size >= p2_y { if ball_y <= p2_y + ph {
            // bounce
            ball_x = p2_x - ball_size
            ball_vx = -ball_vx
          } } else {
            if prev_y + ball_size >= p2_y { if prev_y <= p2_y + ph {
              // bounce (swept)
              ball_x = p2_x - ball_size
              ball_vx = -ball_vx
            } }
          }
        }
      } else {
        // Fallback to current AABB overlap
        if ball_x + ball_size >= p2_x { if ball_x <= p2_x + pw { if ball_y + ball_size >= p2_y { if ball_y <= p2_y + ph {
          // bounce (AABB)
          ball_x = p2_x - ball_size
          ball_vx = -ball_vx
        }}}}
      }
    }

    // Scoring - ball goes off left/right edges
    if ball_x < 0 { 
      score2 = score2 + 1
      print("Player 2 scores! Score:", score1, "-", score2)
      ball_x = 400
      ball_y = 300
      ball_vx = 5
      ball_vy = 4 
    }
    if ball_x > 800 { 
      score1 = score1 + 1
      print("Player 1 scores! Score:", score1, "-", score2)
      ball_x = 400
      ball_y = 300
      ball_vx = -5
      ball_vy = 4 
    }

    // Render everything
    // Dark background but not black
    sdl.set_draw_color(ren, 40, 40, 60, 255)
    sdl.clear(ren)
    
  // Center line (bright white, thicker)
    sdl.fill_rect(ren, 398, 0, 4, 600, 255, 255, 255, 255)
    
    // Ball (bright yellow, larger)
    sdl.fill_rect(ren, ball_x, ball_y, ball_size, ball_size, 255, 255, 0, 255)
    
    // Left paddle (bright cyan, brighter)
  sdl.fill_rect(ren, p1_x, p1_y, pw, ph, 0, 255, 255, 255)
    
    // Right paddle (bright magenta, brighter)
  sdl.fill_rect(ren, p2_x, p2_y, pw, ph, 255, 0, 255, 255)
    
  // New scoreboard (block digits). Center separator imaginary line at x=400.
  let cell = 14 // size of each block; tweak for aesthetics
  let gap = 30  // distance from center for inner edges
  let top_y = 25
  // Left player score: right-justified against (400 - gap)
  draw_number_right_justified(sdl, ren, 400 - gap, top_y, score1, cell, 255,255,255,255)
  // Right player score: left-justified against (400 + gap)
  draw_number_left(sdl, ren, 400 + gap, top_y, score2, cell, 255,255,255,255)

  sdl.present(ren)
    sdl.delay(16) // ~60 FPS
    frame = frame + 1
    if debug { print("frame", frame, "post present ball", ball_x, ball_y, "scores", score1, score2) }
  }

  print("Game over! Final score:", score1, "-", score2)
  sdl.destroy_renderer(ren)
  sdl.destroy_window(win)
  sdl.quit()
}

// Start the game
main()
